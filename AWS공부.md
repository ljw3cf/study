# 가상화
## 호스트 가상화 (Host Virtualization)
* 구조  
|가상환경|가상환경|  
|App|App|  
|미들웨어|미들웨어|  
|게스트OS|게스트OS|  
|가상화 소프트웨어|  
|호스트 OS|  
|하드웨어|

* 정의  
Base가 되는 호스트 OS 위에 게스트 OS를 올리는 방식.
OS위에 OS를 올리는 방식이기에 매우 느림(오버헤드가 큼)

* 종류  
VM Workstation / VMware / VMware Player / VirtualBox 등등

## 하이퍼바이저 가상화 (Hypervisor Virtualization)
* 정의  
Host OS 없이 하드웨어에 하이퍼바이저를 설치하여 사용하는 방식(베어메탈이라고 부르던 그 것)  
별도의 HostOS가 없어 가볍다.(오버헤드 적다.)


1. 전가상화(Full-Virtualization)


2. 반가상화(Para-Virtualization)


------------------------------------------
확인해봐야 할 개념들
  
AES-256  

RSA  

BASE64  

failover  

쿠키 VS 캐시  

TPS  

--------------------------------------------
## VPC 구축절차(3 Tier 기준)

1. **VPC** 생성 (VPC CIDR 블록 지정)

2. NAT GW 및 Bestion Host 위치할 **Pub 서브넷** 생성  
(가용영역(AZ) / Subnet CIDR 블록 지정)  

3. Web/WAS 서버 및 DB 위치할 **Pri 서브넷** 생성  
(가용영역(AZ) / Subnet CIDR 블록 지정)  

4. 외부와 Pub 서브넷의 통신을 위해 **IGW** 생성

5. **Pub 라우팅 테이블** 생성

6. **Pub 라우팅 편집**  
(Destination은 VPC의 CIDR이고 Target이 local인 라우트가 디폴트로 잡혀있다.)  
(외부와 통신하기 위해 Destination이 모든 네트워크(0.0.0.0/0)이고 Target이 IGW인 라우트를 추가할 것!)

7. **Pub 서브넷 연결**  
(Pub 서브넷 지정)

8. NAT GW 접근을 위해 할당할 **EIP 생성**

9. **NAT GW** 생성  
(Pub 서브넷 지정 / EIP 지정)

10. **Pri 라우팅 테이블** 생성

11. **Pri 라우팅 편집**  
(Destination은 VPC의 CIDR, Target이 local인 라우트가 디폴트로 잡혀있음.)  
(인터넷을 이용할 수 있도록 Destination이 0.0.0.0/0이고 Target이 NAT GW인 라우트를 추가할 것 )

-------------------------------------------------
## NAT 게이트웨이 규칙 및 제한
1. 하나의 EIP만 NAT GW에 연결할 수 있음.
2. 한번 EIP와 연결하면 끊을 수 없음. 다른 EIP를 사용하고 싶다면 새로운 NAT GW를 만들고 라우팅테이블을 업데이트한 다음 기존 NAT GW를 삭제해야 함.
3. 보안그룹 연결불가. NAT GW와 연결되는 Pri 서브넷의 트래픽을 관리하고 싶다면, Pri 사이드의 보안그룹을 수정할 것.
-------------------------------------------------

## 로드 밸런서
### 기본 동작 방식
1. 클라이언트의 웹브라우저에서 도메인 주소 입력
2. 클라이언트의 메인 DNS 서버로 해당하는 도메인 주소의 IP 주소를 문의
3. 메인 DNS 서버는 해당 도메인 주소를 관리하는 하위 DNS 서버에 IP주소를 문의 (계층적으로 문의)
4. 각 하위 DNS 서버는 상위 DNS 서버로 로드밸런서의 IP주소(Virtual IP = VIP)를 메인 DNS 서버에 알려줌
    * VIP: 공인 IP를 여러개의 사설 IP에 매핑시키는 방식
5. 메인 DNS서버는 획득한 VIP주소를 클라이언트에게 전송
6. 클라이언트에서 로드밸런서의 VIP주소로 http 요청
7. 로드밸런서는 별도의 로드밸런싱 방법(라운드 로빈 등)을 통해 실제 서버에 요청을 전송
8. 서버의 작업 결과를 받은 로드밸런서는 전달받은 요청결과를 클라이언트에게 전송  
  
### 로드밸런서의 기본 기능
1. Health Check  
로드밸런서에서 서버 장애여부를 지속적으로 체크하는 방법.  
로드밸런서 타입에 따라 작동방식이 다르다.
    * L4 (AWS의 NetworkLoadBalancer): TCP, UDP등 4계층에 해당하는 프로토콜로 특정 포트에 패킷을 날려 장애여부를 확인한다.   (NetworkLoadBalancer의 경우 TCP, UDP, TLS 지원) 
    * L7 (AWS의 ApplicationLoadBalancer): HTTP, HTTPS 등 7계층에 해당하는 프로토콜로 특정 포트에 패킷을 날려 장애여부를 확인한다.  
    (ApplicationLoadBalancer의 경우 HTTP, HTTPS, gRPC 지원)

2. Tunneling  
두 네트워크 간 가상의 터널(링크)를 뚫고 캡슐화된 패킷 구별한 뒤 캡슐을 해제(Decapsulation)함

3. NAT(Network Address Translation)
사설IP가 외부와 통신하기 위해 사설IP를 공인IP로 변환하는 방식
    * SNAT(SourceNAT): 내부에서 외부로 트래픽이 나가는 경우. (ex) 라우터)
    * DNAT(DestinationNAT): 외부에서 내부로 트래픽이 들어오는 경우. (ex) 로드밸런서) 

4. DSR(Direct Server Routing)
서버에서 클라이언트로 되돌아가는 경우, 목적지를 클라이언트로 설정 후 네트워크 장비나 로드밸런서를 거치지 않고 바로 클라이언트를 찾아가는 방식  
(로드밸런서의 부하를 줄여주는 장점)

### Application Load Balancer(AWS)  
AWS가 제공하는 L7 Load Balancer에 해당하는 서비스.
ALB는 다음 요소들로 구성되어 있음.
1. LoadBalancer  
    * 클라이언트에게 접근을 위한 단일 포인트를 제공.   
    * 클라이언트는 로드밸런서에 요청을 보내고, 로드밸런서는 타겟(Ex) EC2 Instances)에게 해당 요청을 보낸다.  
    * 3가지 타입의 서브넷을 지정 가능.   
    ((1) 가용영역 (2) 로컬영역 (3) Outpost)
    * 보안 그룹 설정가능
    * 연결유휴제한시간(Connection idle timeout): 백엔드 연결(LB->Server)에 대한 제한시간을 설정할 수 있다.  
    만약 백엔드 연결시간이 설정한 제한시간을 초과하면 LB는 프론트엔드 연결(Client->LB)에 대한 연결을 끊어버린다.  
    디폴트 60초이며, 변경가능.
    * 삭제방지: LB가 실수로 삭제되는 것을 방지하기 위한 기능. 디폴트는 비활성화 상태.

2. Listener
    * 포트와 프로토콜을 사용하여 연결 확인을 하기위한 기능.
    * 지원 프로토콜: HTTP, HTTPS
    * 지원 포트: 1 ~ 65535

3. Target Group
    * 타겟들에게 요청을 라우팅하기 위해 지정
    * 타겟 종류: EC2 instance, IP, Lambda Function
    * EC2 instance의 경우 AutoScailing Group을 지정할 수도 있다.

ALB에서 발생가능한 문제와 트러블슈팅 방안은 다음과 같다.
1. 등록된 대상(Target)은 서비스되지 않고 있습니다.  
    * 대상이 Inservice상태로 들어가는데 시간이 오래걸리거나, 정상 상태가 아님.
    * 대상이 인스턴스인 경우 확인해볼만한 상황     
        1) 인스턴스와 연결된 보안그룹 확인
        2) 서브넷에 연결된 ACL 확인
        3) 상태 확인을 위한 경로(페이지)가 정확한가?
        4) 유휴 연결 제한 시간이 적당한가?
        5) 대상이 성공적 응답 코드를 반환하지 않음
2. 클라이언트가 인터넷 경계(Internet-facing) 로드 밸런서에 연결할 수 없음.
    * 로드 밸런서가 요청에 응답하지 않는 경우  
    * 확인해볼만한 상황
        1) 연결된 서브넷이 퍼블릭이 아닌 프라이빗에 위치한게 아닌지?
        2) 로드밸런서와 연결된 보안그룹 확인
        3) 서브넷에 연결된 ACL 확인
3. 로드 밸런서가 비정상 상태 대상에 요청을 전송
    * 대상그룹(Target Group)에 포함된 대상들이 전부 Unhealty한 경우 발생.  
    (ALB는 대상그룹에 Healthy한 대상이 하나라도 존재한다면, Healty한 타겟에게만 요청을 보냄)
    * 대상그룹 상태확인할 것
4. 로드 밸런서가 응답 코드 000을 보냅니다.
    * HTTP/2 연결을 사용하는 경우 헤더의 압축 길이가 8K를 초과하면, ALB는 GOAWY 프레임을 보내고 TCP FIN 연결을 종료 **(??? 확인필요)**
5. 로드 밸런서가 HTTP 오류 코드를 생성
    * 
6. 대상이 HTTP 오류 코드를 생성
    * HTTP 400: 잘못된 요청
        1. 클라이언트가 HTTP 사양을 충족하지 않는 잘못된 형식의 요청을 전송한 경우
        2. 요청헤더가 요청라인당 16k를 초과하거나, 단일헤더당 16k를 초과하거나, 전체헤더당 64k를 초과한 경우
    * HTTP 401 (권한 없음): 사용자를 인증하도록 리스너 규칙을 구성했지만, 다음중 하나가 True다.
        (1). 인증되지 않은 사용자를 거부하도록 OnUnauthenticatedRequest를 구성했거나 ldp가 액세스를 거부함.  
    * HTTP 403 (금지됨): ACL규칙에 의거하여 해당 사용자가 금지됨
    * HTTP 405 (허용되지 않은 메쏘드): 클라이언트가 사용한 Trace방식이 ALB에서 지원하지 않음. ***(???)***
    * HTTP 408 (요청시간 초과): 클라이언트가 유휴시간 만료 전에 데이터를 전송하지 않았음. 유휴시간의 길이를 늘릴 것
    * HTTP 413 (페이로드가 너무 큼): 대상이 Lambda Function이고, 요청 본문이 1MB를 초과함
    * HTTP 414 (URL이 너무 김): 요청 URL 또는 쿼리 문자열이 너무 김
    * HTTP 460: 로드 밸런서가 클라이언트로 요청은 수신되었음. 하지만 유휴 제한 시간이 종료되기 전에 클라이언트가 로드밸런서에 대한 연결을 종료하였음. 클라이언트 제한 시간이 로드밸런서 제한 시간보다 큰지 확인할 것.
    * HTTP 463: 로드밸런서가 IP주소가 30개가 넘는 X-Forwarded-For 요청헤더를 받았음.
    (X-Forwarded-For(XFF): 요청이 어디서 건너왔는지 알려주는 헤더. 원본 IP와 중개서버 IP가 표기됨)
    * HTTP 500 (내부 서버 오류): AWS WAF 웹ACL을 구성하였으며, 웹 ACL규칙을 실행하는데 오류가 발생함.
    * HTTP 501 (구현되지 않음): 
    * HTTP 502 (잘못된 게이트웨이): 
    * HTTP 503 (서비스 사용 불가): 로드밸런서 대상그룹에 등록된 대상이 없음. 대상그룹 확인할 것
    * HTTP 504 (게이트웨이 시간 초과):  
        (1). 연결 제한 시간이 만료되기 전에 로드밸런서가 대상에 대한 연결을 설정하지 못함. 
        (2). 서브넷의 ACL에서 Ephemeral port에 대한 접근을 허용하지 않음.
        (3).로드 밸런서가 대상에 대한 연결을 설정했지만, 유휴 제한 시간이 끝나기 전에 대상이 응답을 하지 않음
        (4). 대상이 body보다 긴 header로 응답한 경우.
        (5). 대상이 Lambda함수고, Lambda 서비스가 연결 제한 시간이 만료되기 전에 응답하지 않은 경우.
    * HTTP 561 (권한 없음): 사용자를 인증하도록 리스너 규칙을 구성했지만, 사용자를 인증할 때 ldp가 오류코드를 반환.
### Network Load Balancer(AWS)  

--------------------------------------------------
# Network ACL vs Security Group
## Network ACL
1. 정의: **서브넷 단위**로 **외부간 통신**을 담당하는 보안기능  
2. Stateless 필터링 방식: 요청 정보를 따로 저장하지 않음. 응답하는 트래픽에 대한 필터링을 설정해야 함.
3. 화이트리스트 방식(허용할 트래픽만 등록)
4. 등록된 규칙의 번호순으로 트래픽을 허용하거나 거부함 (낮은 번호가 우선순위가 높다.)
5. Inbound에 어떤 정책이 적용되서 들어와도 Outbound 정책이 거부하면 응답실패
6. Ephemeral 포트는 개방해야 함  
(Ephemeral port: 클라이언트가 TCP 요청을 보내기 위해 임시로 bind하는 포트)

## Security Group
1. 정의: **EC2 인스턴스 단위**로 **내부간 통신**을 담당하는 보안기능  
2. Stateful 필터링 방식: 요청 정보를 저장. 응답하는 트래픽에 대해 트래픽 제어를 하지 않음.
3. 화이트리스트 + 블랙리스트 방식 **(???)**
4. 등록된 모든 규칙을 평가하여 트래픽을 허용함
5. Inbound에 어떤 정책이 적용되서 들어오면 Outbound 정책은 신경쓰지 않아도 됨 **(테스트해볼 것)**
6. 동일한 서브넷간의 통신의 경우 ACL은 무시되고 Security Group의 보안만 적용됨.

--------------------------------------------------
## VPC Peering
1. 정의: 서로 다른 VPC간 연결을 의미한다. 리전간 VPC Peering도 가능하다. 또한 다른 계정간 Peering도 가능하다.
2. 제한사항:
    * 연결하려는 VPC끼리 CIDR이 동일하면 안됨
    * VPC A <-> VPC B 그리고 VPC B <-> VPC C Peering하였을 때, VPC A <-> VPC C는 라우팅 안됨.

--------------------------------------------------
## Memcached
1. 정의: 고성능의 분산 메모리 객체 캐싱 시스템.
2. 기능: DB의 부하를 완화시켜 동적 웹어플리케이션의 속도를 향상시킬 수 있다.
3. 작동원리: DB나 API호출 또는 페이지 렌더링 등으로 받아오는 데이터를 작은 단위의 Key-Value 형식으로 캐싱하는 방식.


--------------------------------------------------
## Transaction과 TPS
1. Transaction
    * 정의: SQL을 이용하여 데이터베이스에 접근하기위해 수행하는 작업의 단위

--------------------------------------------------
## 세션 vs 쿠키 vs 캐시
1. HTTP의 특징  
    (1) Stateless: 클라이언트의 상태정보를 저장하지 않음. 첫번째 통신에서 데이터를 주고받아도 두번째 통신에서 이전 데이터를 유지하지 않음.  
  
    (2) Connectionless: 클라이언트의 요청에 대한 응답을 하고 연결을 끊어버림.

    이런 특징에도 불구하고 데이터 유지가 필요한 경우가 많음 => 이를 극복하기 위해 세션, 쿠키, 캐시가 등장.

2. 쿠키  
    (1). **사용자의 브라우저**에 저장  
    (2). **텍스트 데이터 파일, 이름, 값 만료기간, 경로 정보** 포함  
    (3). 해당 브라우저를 사용하면 누구나 쿠키 데이터를 확인가능 (보안성 낮음!)

3. 세션  
    (1). **서버**에 저장  
    (2). **브라우저 종료할 때 까지** 유지  
    (3). 클라이언트 사이드에서 세션확인 불가 (비교적 보안성 높음)

4. 캐시  
    (1) **정적 컨텐츠**들을 **클라이언트**에 저장  
    (2) **클라이언트에 저장되므로 빠름**  
